스프링의 가장 중요한 기능은 DI와 IoC이다. IoC는 여러가지 방버브올 이루어질 수 있는데 대표적인 것은 XML을 이용한 세팅파일을 사용하는 것이다.

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id="exam" class="lec5.entity.NewlecExam">
		<property name="kor" value="100"/>
		<property name="math" value="100"/>
		<property name="eng" value="100"/>
		<property name="com" value="100"/>
		
		<constructor-arg index="0" value="10"/>
		<constructor-arg index="1" value="20"/>
		<constructor-arg index="2" value="30"/>
		<constructor-arg index="3" value="40"/>
		
	</bean>
	<bean id="console" class="lec5.ui.GridExamConsole">
		<property name="exam" ref="exam"/>
	</bean>
	
</beans>

bean : 객체를 미리 만들어놓기 위한 태그
<property> : 파라미터 값을 넣기 위한 태그
<constructor-arg/> : 필드를 가진 생성자를 호출할 때 사용, property 넣는 것과 똑같아
type : value 태그에서 변수 타입을 명시적으로 정할 때 사용한다. 
필드를 가진 생성자를 직접 지정하는 방식을 상요하면 번거로울 수 있어 : 추가적인 처리기를 사용하는 방법을 사용하면 좋다.

xmlns:namespace : 이 태그를 이용하여 같은 종류 클래스의 객체를 ㄹ구분할 수 있고, 특정 처리기가 담당하는 속성임을 표시
 => ex ) <bean id="exam" class="lec5.entity.NewlecExam" p:kor="40" p:eng="30" p:com="20" p:math="10"/>
 xmlns:name="http://www.springframework.org/schema/name"
 일단 기본적으로 필드없는 생성자로 생성한 후, setter로 넣는 방식임
 
 Collection : ArrayList 같이 값을 파라미터로 추가하는 것이 아니라 여러가지로 추가하는 경우?
 	add는 일단 setter가 아님 -> 그래서 생성할 때 collection을 이용하여 추가할 수 있다.
 	
 	example : 
 	<bean id="exams" class="java.util.ArrayList">
		<constructor-arg>
			<list>
				<bean id="exam" class="lec5.entity.NewlecExam" p:kor="40" p:eng="30" p:com="20" p:math="10"/>
				<bean id="exam" class="lec5.entity.NewlecExam" p:kor="40" p:eng="30" p:com="20" p:math="10"/>
				<bean id="exam" class="lec5.entity.NewlecExam" p:kor="40" p:eng="30" p:com="20" p:math="10"/> // 직접 생성
				<ref bean="exam"/> <!--이미 생성된 객체 참조 방식 -->
			</list>
		</constructor-arg>
	</bean>
	
util schema : 목록을 사용할 때 진짜 객체를 만들어줌, 그냥 생성할 때 사용하는 <list랑 다름>
annotation : compiler에게 미리 옵션을 알려주는 것!!

autowired annotation을 확인하게 하기 위해서는 키워드가 필요, xml에 context-keyword 필요
<context:annotation-config/>

그러면 바인드는 어떤걸 근거로 이루어지는 가?

ApplicationContext context = 
				new AnnotationConfigApplicationContext(NewlecAppConfig.class);

 AnnotationConfigApplicationContext중 register refresh를 이용하면 config 설정을 여러개를 할 수 있고, 들록도 여러번 가능하다
 @Qualifier : Autowired가 정확히 어떻게 연결해줄 것인가?
 	1. 자료형 기준으로 찾는다!!(1순위)
 	2. 메서드 정의 부분 파라미터 변수명으로 찾는다!!(2순위)
 	
 		정답음 자료형을 기준으로 찾는다(IoC 컨테이너가 가지고 있는 같은 필요한 종류의 클래스 객체 이용)
 		
 그러면 이미 같은 종류 클래스 객체가 2개가 있는 경우 : error(부정확한 지시) => 그래서 지시가 필요함
 
 	스프링은 똑똑해서 2. 메서드 정의 부분 파라미터 변수명으로 찾는다!! 여거개의 같은 종류의 클래스가 있는 경우
 	
 @Qualifier를 이용하면 명시적으로 정할 수 있다.(근데 이 건 무조건 IoC 안에 객체가 있어야 함) => 겍체가 없는 경우 만들어주기를 원함 : Autowried 에 require로 속성 넣주면 null인 경우에도 에러가 안남
 
 @AutoWired의 위치 : 필드 위(기본생성자 호출후 setter->생성자가 있어야 함), 생성자 위(당연, 기본생성자 없어도 됨), setter 위(당연, 기본 생성자 있어야 함)
 @Component : 어노테이션을 읽을 일이 없어서 미리 설정해주어야 함(객체 생성)
 @Value() : 기본값을 넣어줄 수 있음
 
 
 
 
 
 
 
 
 
 
 
 